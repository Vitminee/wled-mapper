<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>WLED Mapping Viewer</title>
  <style>
    body { margin: 0; font-family: Arial, sans-serif; background: #0f1115; color: #f1f1f1; }
    #layout { display: flex; flex-direction: column; min-height: 100vh; }
    #controls { display: flex; flex-direction: column; gap: 12px; padding: 16px; background: #151821; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    .control-row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    button, .field { background: #1f2430; color: #f1f1f1; border: 1px solid #2d3240; padding: 6px 12px; cursor: pointer; font-size: 0.9rem; }
    button:hover { background: #2b3242; }
    .field { display: flex; align-items: center; gap: 8px; cursor: default; }
    .field input[type=number], .field select, .field input[type=range] { width: 110px; background: #0f1115; border: 1px solid #2d3240; color: #f1f1f1; padding: 4px 6px; }
    .field select { appearance: none; -moz-appearance: none; -webkit-appearance: none; }
    .step-control { display: flex; align-items: center; gap: 8px; }
    .step-control input[type=range] { width: 160px; padding: 0; }
    .step-control input[type=number] { width: 70px; }
    .hidden { display: none !important; }
    #panels { display: flex; flex: 1; gap: 16px; padding: 16px; box-sizing: border-box; }
    .panel { flex: 1; background: #11141d; border: 1px solid #1f2430; padding: 12px; box-sizing: border-box; display: flex; flex-direction: column; gap: 12px; }
    .panel-head { display: flex; align-items: center; gap: 12px; }
    .panel h2 { margin: 0; font-size: 1rem; color: #dbe3ff; }
    .canvas-wrap { flex: 1; position: relative; background: #08090d; border: 1px solid #232938; display: flex; justify-content: center; align-items: center; }
    .camera-preview-wrap { flex: 1; position: relative; background: #08090d; border: 1px solid #232938; display: flex; justify-content: center; align-items: center; min-height: 220px; }
    #cameraPreview { max-width: 100%; max-height: 100%; object-fit: contain; display: block; }
    #previewStatus { font-size: 0.85rem; color: #b5bcc9; }
    canvas { width: 100%; height: 100%; }
    #status { font-size: 0.9rem; color: #b5bcc9; }
    #summary { font-size: 0.9rem; color: #ced6f3; }
    @media (max-width: 1100px) { #panels { flex-direction: column; } }
  </style>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta charset="utf-8" />
  <meta name="referrer" content="same-origin" />
  <meta name="color-scheme" content="dark" />
</head>
<body>
  <div id="layout">
    <div id="controls">
      <div class="control-row">
        <label class="field">Host <input id="hostInput" type="text" placeholder="http://wled.local" style="width:200px"></label>
        <label class="field">LEDs <input id="countInput" type="number" min="1" step="1" value="150"></label>
        <label class="field">Camera
          <select id="cameraSelect">
            <option value="" disabled selected>Scanning...</option>
          </select>
          <input id="cameraManualInput" type="number" min="0" step="1" value="0" class="hidden" title="Enter camera index manually when scanning is unavailable">
        </label>
        <button id="cameraScanBtn" type="button">Scan Cameras</button>
        <label class="field">Segment <input id="segmentInput" type="number" min="0" step="1" value="0"></label>
        <label class="field">Frames/LED <input id="framesInput" type="number" min="1" step="1" value="5"></label>
        <label class="field">Transition (ms) <input id="transitionInput" type="number" min="0" max="65000" step="50" value="0"></label>
        <label class="field">Min Bright <input id="minBrightInput" type="number" min="1" step="1" value="30"></label>
        <label class="field"><input id="skipDimToggle" type="checkbox"> Skip dim LEDs</label>
        <label class="field">Prelight (s) <input id="prelightInput" type="number" min="0" step="0.05" value="0.3"></label>
        <label class="field">Capture (s) <input id="captureInput" type="number" min="0" step="0.05" value="0.6"></label>
        <label class="field">Postlight (s) <input id="postlightInput" type="number" min="0" step="0.05" value="0.2"></label>
        <button id="startBtn">Start Mapping</button>
        <button id="stopBtn" disabled>Stop Mapping</button>
        <button id="reloadBtn">Reload CSV</button>
        <span id="status"></span>
      </div>
      <div class="control-row">
        <label class="field step-field">Step
          <div class="step-control">
            <input id="stepSlider" type="range" min="1" max="80" step="1" value="10">
            <input id="stepNumber" type="number" min="1" max="80" step="1" value="10">
            <span id="stepValue">10</span>
          </div>
        </label>
        <label class="field">Width <input id="widthInput" type="number" min="1" step="1" placeholder="auto"></label>
        <label class="field">Height <input id="heightInput" type="number" min="1" step="1" placeholder="auto"></label>
        <button id="generateBtn">Generate ledmap.json</button>
        <button id="generateGapsBtn">Download 2D gaps</button>
      </div>
      <div class="control-row">
        <span id="summary"></span>
      </div>
    </div>
    <div id="panels">
      <div class="panel preview-panel">
        <div class="panel-head">
          <h2>Camera Preview</h2>
          <button id="previewRefreshBtn" type="button">Refresh Preview</button>
          <span id="previewStatus"></span>
        </div>
        <div class="camera-preview-wrap">
          <img id="cameraPreview" alt="Camera preview" />
        </div>
      </div>
      <div class="panel">
        <div class="panel-head">
          <h2>Camera Space</h2>
          <label class="field"><input id="wireToggle" type="checkbox"> Wire LEDs (in order)</label>
        </div>
        <div class="canvas-wrap"><canvas id="sourceCanvas" width="640" height="640"></canvas></div>
      </div>
      <div class="panel">
        <h2>Grid Preview</h2>
        <div class="canvas-wrap"><canvas id="gridCanvas" width="640" height="640"></canvas></div>
      </div>
    </div>
  </div>

  <script>
    const csvCandidates = ["/data/mapping.csv", "data/mapping.csv", "../data/mapping.csv", "./data/mapping.csv"];    
    const pointRadius = 6;

    const sourceCanvas = document.getElementById('sourceCanvas');
    const gridCanvas = document.getElementById('gridCanvas');
    const sourceCtx = sourceCanvas.getContext('2d');
    const gridCtx = gridCanvas.getContext('2d');

    const wireToggle = document.getElementById('wireToggle');
    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary');
    const hostInput = document.getElementById('hostInput');
    const countInput = document.getElementById('countInput');
    const cameraSelect = document.getElementById('cameraSelect');
    const cameraManualInput = document.getElementById('cameraManualInput');
    const cameraScanBtn = document.getElementById('cameraScanBtn');
    const framesInput = document.getElementById('framesInput');
    const segmentInput = document.getElementById('segmentInput');
    const prelightInput = document.getElementById('prelightInput');
    const captureInput = document.getElementById('captureInput');
    const postlightInput = document.getElementById('postlightInput');
    const transitionInput = document.getElementById('transitionInput');
    const minBrightInput = document.getElementById('minBrightInput');
    const skipDimToggle = document.getElementById('skipDimToggle');
    const stepSlider = document.getElementById('stepSlider');
    const stepNumber = document.getElementById('stepNumber');
    const stepValue = document.getElementById('stepValue');
    const widthInput = document.getElementById('widthInput');
    const heightInput = document.getElementById('heightInput');
    const previewImage = document.getElementById('cameraPreview');
    const previewStatus = document.getElementById('previewStatus');
    const previewRefreshBtn = document.getElementById('previewRefreshBtn');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');

    let sourcePoints = [];
    let currentGrid = null;
    let liveRawPoints = [];
    let liveModeActive = false;
    let livePointsCursor = -1;
    let liveFetchPending = false;
    const PREVIEW_REFRESH_INTERVAL = 1000;
    let previewLoopTimer = null;
    let previewLoading = false;
    let previewPaused = false;
    let conversionTimer = null;

    function formatLedMapText(map, width, height) {
      const lines = ['{"map":', '  ['];
      for (let row = 0; row < height; row += 1) {
        const start = row * width;
        const rowValues = map.slice(start, start + width);
        const formatted = rowValues.map(value => value.toString().padStart(2, ' ')).join(', ');
        const suffix = row < height - 1 ? ',' : '';
        lines.push('    ' + formatted + suffix);
      }
      lines.push('  ],');
      lines.push('  "width":  ' + width + ',');
      lines.push('  "height": ' + height);
      lines.push('}');
      return lines.join('\n') + '\n';
    }

    async function fetchFirst(urls) {
      for (const url of urls) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (res.ok) return await res.text();
        } catch (_) { /* ignore */ }
      }
      throw new Error('mapping.csv not found');
    }

    function parseCsv(text) {
      const rows = text.trim().split(/\r?\n/);
      if (!rows.length) return [];
      const headers = rows.shift().split(',').map(h => h.trim().toLowerCase());
      return rows.filter(Boolean).map(row => {
        const parts = row.split(',');
        const rec = {};
        headers.forEach((k, i) => { rec[k] = Number(parts[i]); });
        return rec;
      });
    }

    function getSelectedCameraIndex() {
      if (cameraSelect && !cameraSelect.classList.contains('hidden') && cameraSelect.value !== '') {
        return Number(cameraSelect.value);
      }
      if (cameraManualInput && !cameraManualInput.classList.contains('hidden')) {
        return Number(cameraManualInput.value || 0);
      }
      return 0;
    }

    async function refreshCameraList() {
      if (!cameraSelect) { return; }
      const previousValue = cameraSelect.value;
      cameraSelect.disabled = true;
      cameraSelect.innerHTML = '<option value="" disabled>Scanning...</option>';
      previewStatus.textContent = 'Scanning cameras...';
      cameraSelect.classList.remove('hidden');
      if (cameraManualInput) { cameraManualInput.classList.add('hidden'); }
      try {
        const res = await fetch('/api/cameras?max_index=12', { cache: 'no-store' });
        if (!res.ok) { throw new Error('Camera scan failed'); }
        const data = await res.json();
        const cameras = Array.isArray(data.cameras) ? data.cameras : [];
        cameraSelect.innerHTML = '';
        if (!cameras.length) {
          const option = document.createElement('option');
          option.value = '';
          option.textContent = 'No cameras found';
          cameraSelect.appendChild(option);
          cameraSelect.value = '';
          cameraSelect.disabled = true;
          previewStatus.textContent = 'No cameras detected â€“ enter an index manually';
          if (previewImage) { previewImage.removeAttribute('src'); }
          if (cameraManualInput) { cameraManualInput.classList.remove('hidden'); }
          return;
        }
        const frag = document.createDocumentFragment();
        cameras.forEach(cam => {
          const option = document.createElement('option');
          option.value = String(cam.index);
          option.textContent = `Camera ${cam.index}`;
          frag.appendChild(option);
        });
        cameraSelect.appendChild(frag);
        const retained = cameras.find(cam => String(cam.index) === previousValue);
        cameraSelect.value = retained ? String(retained.index) : String(cameras[0].index);
        cameraSelect.disabled = false;
        previewStatus.textContent = '';
        if (cameraManualInput) {
          cameraManualInput.classList.add('hidden');
          cameraManualInput.value = cameraSelect.value || '0';
        }
        await refreshPreview();
      } catch (err) {
        cameraSelect.innerHTML = '';
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'Scan failed';
        cameraSelect.appendChild(option);
        cameraSelect.value = '';
        cameraSelect.disabled = true;
        previewStatus.textContent = err && err.message ? err.message : 'Camera scan failed';
        if (previewImage) { previewImage.removeAttribute('src'); }
        if (cameraManualInput) { cameraManualInput.classList.remove('hidden'); }
        cameraSelect.classList.add('hidden');
      } finally {
        startPreviewLoop();
      }
    }

    async function refreshPreview(force = false) {
      if (!previewImage) { return; }
      const selectVisible = cameraSelect && !cameraSelect.classList.contains('hidden');
      if (selectVisible && cameraSelect.value === '') {
        previewStatus.textContent = 'Select a camera to preview';
        previewImage.removeAttribute('src');
        return;
      }
      const manualVisible = cameraManualInput && !cameraManualInput.classList.contains('hidden');
      if (manualVisible && (!cameraManualInput.value && cameraManualInput.value !== '0')) {
        previewStatus.textContent = 'Enter a camera index';
        previewImage.removeAttribute('src');
        return;
      }
      const index = getSelectedCameraIndex();
      if (Number.isNaN(index)) { return; }
      if (previewLoading && !force) { return; }
      previewLoading = true;
      previewStatus.textContent = 'Loading preview...';
      const cacheBust = Date.now();
      const url = `/api/camera_preview/${index}?width=640&_=${cacheBust}`;
      return new Promise(resolve => {
        const finish = (message) => {
          previewLoading = false;
          if (message !== undefined) {
            previewStatus.textContent = message;
          }
          resolve();
        };
        previewImage.onload = () => {
          finish('');
        };
        previewImage.onerror = () => {
          finish('Preview failed');
        };
        previewImage.src = url;
      });
    }

    function startPreviewLoop() {
      if (previewLoopTimer || previewPaused) { return; }
      previewLoopTimer = setInterval(() => { refreshPreview(); }, PREVIEW_REFRESH_INTERVAL);
      refreshPreview();
    }

    function stopPreviewLoop() {
      if (!previewLoopTimer) { return; }
      clearInterval(previewLoopTimer);
      previewLoopTimer = null;
    }

    function pausePreview(message) {
      previewPaused = true;
      stopPreviewLoop();
      if (previewImage) { previewImage.removeAttribute('src'); }
      previewStatus.textContent = message || 'Camera in use during mapping';
    }

    function resumePreview() {
      previewPaused = false;
      startPreviewLoop();
    }

    function getStepValue() {
      return stepSlider ? Number(stepSlider.value) : undefined;
    }

    function scheduleConversion(delay = 400) {
      if (conversionTimer) { clearTimeout(conversionTimer); }
      conversionTimer = setTimeout(() => {
        conversionTimer = null;
        applyConversion(true);
      }, delay);
    }

    async function fetchLivePoints() {
      if (!liveModeActive || liveFetchPending) { return; }
      liveFetchPending = true;
      try {
        const url = `/api/live_points?after=${livePointsCursor}`;
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) { throw new Error('Live points unavailable'); }
        const data = await res.json();
        const points = Array.isArray(data.points) ? data.points : [];
        if (!points.length) { return; }
        points.sort((a, b) => (a.led ?? 0) - (b.led ?? 0));
        liveRawPoints = liveRawPoints.concat(points);
        livePointsCursor = liveRawPoints[liveRawPoints.length - 1].led ?? livePointsCursor;
        sourcePoints = scaleSourcePoints(liveRawPoints);
        renderSource(sourcePoints);
        scheduleConversion(500);
      } catch (err) {
        console.warn('Live point fetch failed', err);
      } finally {
        liveFetchPending = false;
      }
    }

    function scaleSourcePoints(data) {
      if (!data.length) return [];
      const minX = Math.min(...data.map(d => d.x));
      const maxX = Math.max(...data.map(d => d.x));
      const minY = Math.min(...data.map(d => d.y));
      const maxY = Math.max(...data.map(d => d.y));
      const padding = 40;
      const spanX = Math.max(maxX - minX, 1);
      const spanY = Math.max(maxY - minY, 1);
      const scale = Math.min((sourceCanvas.width - padding * 2) / spanX, (sourceCanvas.height - padding * 2) / spanY);
      const offsetX = padding + (sourceCanvas.width - padding * 2 - spanX * scale) / 2;
      const offsetY = padding + (sourceCanvas.height - padding * 2 - spanY * scale) / 2;
      return data.map(item => ({
        led: item.led, brightness: item.brightness,
        x: offsetX + (item.x - minX) * scale,
        y: offsetY + (item.y - minY) * scale,
      }));
    }

    function renderSource(points) {
      sourceCtx.fillStyle = '#08090d';
      sourceCtx.fillRect(0, 0, sourceCanvas.width, sourceCanvas.height);
      sourceCtx.strokeStyle = '#1f2430';
      sourceCtx.strokeRect(0, 0, sourceCanvas.width, sourceCanvas.height);

      if (!points.length) {
        sourceCtx.fillStyle = '#888';
        sourceCtx.font = '14px Arial';
        sourceCtx.textAlign = 'center';
        sourceCtx.textBaseline = 'middle';
        sourceCtx.fillText('No CSV data loaded', sourceCanvas.width / 2, sourceCanvas.height / 2);
        return;
      }

      sourceCtx.font = '11px Arial';
      sourceCtx.textAlign = 'center';
      sourceCtx.textBaseline = 'middle';
      points.forEach(p => {
        sourceCtx.beginPath();
        sourceCtx.fillStyle = '#3b82f6';
        sourceCtx.arc(p.x, p.y, pointRadius, 0, Math.PI * 2);
        sourceCtx.fill();
        sourceCtx.fillStyle = '#f1f1f1';
        sourceCtx.fillText(String(p.led), p.x, p.y);
      });

      if (wireToggle && wireToggle.checked && points.length > 1) {
        const ordered = points.slice().sort((a, b) => a.led - b.led);
        sourceCtx.save();
        sourceCtx.strokeStyle = '#ef4444';
        sourceCtx.lineWidth = 2;
        sourceCtx.beginPath();
        sourceCtx.moveTo(ordered[0].x, ordered[0].y);
        for (let i = 1; i < ordered.length; i += 1) {
          sourceCtx.lineTo(ordered[i].x, ordered[i].y);
        }
        sourceCtx.stroke();
        sourceCtx.restore();
      }
    }

    function renderGrid(grid) {
      gridCtx.fillStyle = '#08090d';
      gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);
      gridCtx.strokeStyle = '#1f2430';
      gridCtx.strokeRect(0, 0, gridCanvas.width, gridCanvas.height);
      if (!grid) {
        gridCtx.fillStyle = '#888';
        gridCtx.font = '14px Arial';
        gridCtx.textAlign = 'center';
        gridCtx.textBaseline = 'middle';
        gridCtx.fillText('No grid produced', gridCanvas.width / 2, gridCanvas.height / 2);
        return;
      }
      const padding = 40;
      const cellSize = Math.min((gridCanvas.width - padding * 2) / grid.width, (gridCanvas.height - padding * 2) / grid.height);
      const startX = (gridCanvas.width - cellSize * grid.width) / 2;
      const startY = (gridCanvas.height - cellSize * grid.height) / 2;
      gridCtx.font = '11px Arial';
      gridCtx.textAlign = 'center';
      gridCtx.textBaseline = 'middle';
      for (let row = 0; row < grid.height; row += 1) {
        for (let col = 0; col < grid.width; col += 1) {
          const idx = row * grid.width + col;
          const led = grid.map[idx];
          const x = startX + col * cellSize;
          const y = startY + row * cellSize;
          gridCtx.strokeStyle = '#1f2430';
          gridCtx.strokeRect(x, y, cellSize, cellSize);
          if (led !== -1) {
            gridCtx.fillStyle = '#2563eb';
            gridCtx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
            gridCtx.fillStyle = '#f8fafc';
            gridCtx.fillText(String(led), x + cellSize / 2, y + cellSize / 2);
          }
        }
      }
    }

    function updateSummary(grid) {
      if (!grid) { summaryEl.textContent = ''; return; }
      summaryEl.textContent = `Grid ${grid.width}x${grid.height} | LEDs: ${grid.map.filter(v => v !== -1).length}`;
    }

    async function loadCsv() {
      liveModeActive = false;
      liveRawPoints = [];
      livePointsCursor = -1;
      statusEl.textContent = 'Loading CSV...';
      try {
        const text = await fetchFirst(csvCandidates);
        const raw = parseCsv(text);
        sourcePoints = scaleSourcePoints(raw);
        renderSource(sourcePoints);
        statusEl.textContent = `CSV loaded (${raw.length} rows)`;
        await applyConversion();
      } catch (err) {
        sourcePoints = [];
        renderSource(sourcePoints);
        statusEl.textContent = err.message || 'Failed to load CSV';
      }
    }

    async function applyConversion(silent = false) {
      const payload = {
        step: getStepValue(),
        width: widthInput.value ? Number(widthInput.value) : undefined,
        height: heightInput.value ? Number(heightInput.value) : undefined,
        include_meta: false,
      };
      if (!silent) { statusEl.textContent = 'Converting...'; }
      try {
        const res = await fetch('/api/convert', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!res.ok) throw new Error('Convert failed');
        const data = await res.json();
        currentGrid = { map: data.map, width: data.width, height: data.height };
        renderGrid(currentGrid);
        updateSummary(currentGrid);
        if (!silent) { statusEl.textContent = `Ready (${currentGrid.width}x${currentGrid.height})`; }
      } catch (err) {
        if (!silent) {
          currentGrid = null;
          renderGrid(null);
          updateSummary(null);
          statusEl.textContent = err.message || 'Conversion failed';
        } else {
          console.debug('Conversion skipped', err);
        }
      }
    }

    async function generateLedmap() {
      await applyConversion();
      if (currentGrid) {
        downloadLedmap();
      }
    }

    // Mapping controls
    let pollTimer = null;
    function setMappingRunning(running) {
      if (startBtn) { startBtn.disabled = running; }
      if (stopBtn) { stopBtn.disabled = !running; }
    }

    async function startMapping() {
      liveRawPoints = [];
      livePointsCursor = -1;
      liveModeActive = true;
      renderSource([]);
      const payload = {
        host: hostInput.value || 'http://wled.local',
        led_count: Number(countInput.value) || 1,
        camera_index: getSelectedCameraIndex(),
        frames_per_led: Number(framesInput.value) || 5,
        min_brightness: Number(minBrightInput.value) || 30,
        segment_index: Number(segmentInput.value) || 0,
        transition_ms: Number(transitionInput.value) || 0,
        prelight_delay: Number(prelightInput.value) || 0,
        capture_delay: Number(captureInput.value) || 0,
        postlight_delay: Number(postlightInput.value) || 0,
        skip_dim_leds: !!(skipDimToggle && skipDimToggle.checked),
      };
      statusEl.textContent = 'Starting mapping...';
      try {
        setMappingRunning(true);
        const res = await fetch('/api/map', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!res.ok) throw new Error('Failed to start mapping');
        pausePreview('Camera in use during mapping');
        fetchLivePoints().catch(() => {});
        // Poll status
        if (pollTimer) { clearInterval(pollTimer); }
        pollTimer = setInterval(async () => {
          try {
            const sres = await fetch('/api/status', { cache: 'no-store' });
            if (!sres.ok) throw new Error('status failed');
            const st = await sres.json();
            const cur = st.current ?? 0;
            const tot = st.total ?? 0;
            statusEl.textContent = `${st.message || st.status} ${cur}/${tot}`;
            const capturing = st.status === 'running' || st.status === 'starting';
            liveModeActive = capturing;
            if (capturing) {
              pausePreview('Camera in use during mapping');
              await fetchLivePoints();
            }
            if (st.status === 'completed' || st.status === 'error' || st.status === 'stopped') {
              clearInterval(pollTimer);
              pollTimer = null;
              liveModeActive = false;
              resumePreview();
              setMappingRunning(false);
              if (st.status === 'completed') {
                // Auto-reload CSV once done
                await loadCsv();
                statusEl.textContent = 'Capture finished; CSV loaded';
              } else if (st.status === 'stopped') {
                await loadCsv();
                statusEl.textContent = 'Capture stopped';
              }
            }
          } catch (_) { /* ignore transient errors */ }
        }, 800);
      } catch (err) {
        statusEl.textContent = err.message || 'Mapping start failed';
        liveModeActive = false;
        liveRawPoints = [];
        livePointsCursor = -1;
        resumePreview();
        setMappingRunning(false);
      }
    }

    async function stopMapping() {
      if (stopBtn) { stopBtn.disabled = true; }
      statusEl.textContent = 'Stopping mapping...';
      try {
        const res = await fetch('/api/stop', { method: 'POST' });
        if (!res.ok) throw new Error('Stop request failed');
      } catch (err) {
        statusEl.textContent = err.message || 'Stop failed';
        if (stopBtn) { stopBtn.disabled = false; }
      }
    }

    function downloadLedmap() {
      if (!currentGrid) { statusEl.textContent = 'No grid to download'; return; }
      const formatted = formatLedMapText(currentGrid.map, currentGrid.width, currentGrid.height);
      const blob = new Blob([formatted], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'ledmap.json';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function downloadGaps() {
      if (!currentGrid) { statusEl.textContent = 'No grid to download'; return; }
      const gap = currentGrid.map.map(v => (v === -1 ? -1 : 1));
      const lines = ['['];
      for (let row = 0; row < currentGrid.height; row += 1) {
        const start = row * currentGrid.width;
        const rowValues = gap.slice(start, start + currentGrid.width);
        const suffix = row < currentGrid.height - 1 ? ',' : '';
        lines.push('    ' + rowValues.map(v => v.toString().padStart(2, ' ')).join(', ') + suffix);
      }
      lines.push(']');
      const blob = new Blob([lines.join('\n') + '\n'], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = '2d-gaps.json';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    document.getElementById('reloadBtn').addEventListener('click', loadCsv);
    document.getElementById('startBtn').addEventListener('click', startMapping);
    document.getElementById('generateBtn').addEventListener('click', generateLedmap);
    document.getElementById('generateGapsBtn').addEventListener('click', async () => {
      if (!currentGrid) {
        await applyConversion();
        if (!currentGrid) { return; }
      }
      downloadGaps();
    });
    if (wireToggle) { wireToggle.addEventListener('change', () => renderSource(sourcePoints)); }
    if (cameraScanBtn) { cameraScanBtn.addEventListener('click', () => { refreshCameraList(); }); }
    if (cameraSelect) { cameraSelect.addEventListener('change', () => { refreshPreview(true); startPreviewLoop(); }); }
    if (cameraManualInput) { cameraManualInput.addEventListener('change', () => { refreshPreview(true); startPreviewLoop(); }); }
    if (previewRefreshBtn) { previewRefreshBtn.addEventListener('click', () => { refreshPreview(true); }); }
    if (stopBtn) { stopBtn.addEventListener('click', stopMapping); }
    if (stepSlider && stepNumber && stepValue) {
      const syncFromSlider = () => {
        stepNumber.value = stepSlider.value;
        stepValue.textContent = stepSlider.value;
      };
      const syncFromNumber = () => {
        const clamped = Math.min(Math.max(Number(stepNumber.value) || 1, 1), 80);
        stepNumber.value = clamped;
        stepSlider.value = clamped;
        stepValue.textContent = clamped;
      };
      syncFromSlider();
      stepSlider.addEventListener('input', () => {
        syncFromSlider();
        scheduleConversion(200);
      });
      stepNumber.addEventListener('input', () => {
        syncFromNumber();
        scheduleConversion(200);
      });
    }
    if (widthInput) { widthInput.addEventListener('input', () => { scheduleConversion(400); }); }
    if (heightInput) { heightInput.addEventListener('input', () => { scheduleConversion(400); }); }
    if (stepSlider && stepValue) {
      stepValue.textContent = stepSlider.value;
      stepSlider.addEventListener('input', () => {
        stepValue.textContent = stepSlider.value;
        scheduleConversion(200);
      });
    }
    if (widthInput) { widthInput.addEventListener('input', () => { scheduleConversion(400); }); }
    if (heightInput) { heightInput.addEventListener('input', () => { scheduleConversion(400); }); }
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) { stopPreviewLoop(); }
      else { startPreviewLoop(); }
    });

    refreshCameraList();
    loadCsv();
    renderGrid(null);
  </script>
</body>
</html>
